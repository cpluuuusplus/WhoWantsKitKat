package com.ensaitechnomobile.OSM;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.params.CoreProtocolPNames;
import org.json.JSONException;
import org.json.JSONObject;
import org.osmdroid.DefaultResourceProxyImpl;
import org.osmdroid.ResourceProxy;
import org.osmdroid.http.HttpClientFactory;
import org.osmdroid.http.IHttpClientFactory;
import org.osmdroid.tileprovider.tilesource.TileSourceFactory;
import org.osmdroid.util.GeoPoint;
import org.osmdroid.views.MapController;
import org.osmdroid.views.MapView;
import org.osmdroid.views.overlay.ItemizedIconOverlay;
import org.osmdroid.views.overlay.OverlayItem;

import android.app.ProgressDialog;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Point;
import android.location.Location;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBarActivity;
import android.support.v7.widget.SearchView;
import android.text.InputType;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.widget.Toast;

import com.ensai.appli.R;
import com.ensaitechnomobile.common.metier.City;
import com.ensaitechnomobile.exceptions.CityNotFoundException;
import com.ensaitechnomobile.meteo.Meteo;
import com.ensaitechnomobile.meteo.metier.EtatMeteo;
import com.ensaitechnomobile.meteo.metier.EtatMeteoJSON;

public class OSM extends ActionBarActivity {

	private SearchView searchView;
	private MenuItem searchItem;
	private MapView myOpenMapView;
	private MapController myMapController;
	protected static final String APIID = "ef5e65bcdadbcc86a991779742664324";
	protected static final String TAG = "OSM::";
	private double longitude, latitude;
	private LocationManager locationManager;
	private ArrayList<OverlayItem> overlayItemArray;
	private ProgressDialog progressDialog;
	private String country = null;

	/** Called when the activity is first created. */
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_osm);
		progressDialog = new ProgressDialog(this);

		HttpClientFactory.setFactoryInstance(new IHttpClientFactory() {
			public HttpClient createHttpClient() {
				final DefaultHttpClient client = new DefaultHttpClient();
				client.getParams().setParameter(CoreProtocolPNames.USER_AGENT,
						"ensaitechnomobiles.AMS");
				return client;
			}
		});

		myOpenMapView = (MapView) findViewById(R.id.mapview);
		myOpenMapView.setTileSource(TileSourceFactory.CYCLEMAP);
		// myOpenMapView.setTileSource(TileSourceFactory.MAPNIK);
		// myOpenMapView.setTileSource(TileSourceFactory.MAPQUESTOSM);
		// myOpenMapView.setTileSource(TileSourceFactory.PUBLIC_TRANSPORT);
		// myOpenMapView.setTileSource(TileSourceFactory.MAPQUESTAERIAL);

		myOpenMapView.setBuiltInZoomControls(true);
		myOpenMapView.setMultiTouchControls(true);
		myMapController = (MapController) myOpenMapView.getController();
		myMapController.setZoom(15);

		// --- Create Overlay
		overlayItemArray = new ArrayList<OverlayItem>();

		DefaultResourceProxyImpl defaultResourceProxyImpl = new DefaultResourceProxyImpl(
				this);
		MyItemizedIconOverlay myItemizedIconOverlay = new MyItemizedIconOverlay(
				overlayItemArray, null, defaultResourceProxyImpl);
		myOpenMapView.getOverlays().add(myItemizedIconOverlay);
		// ---

		localiserDevice();
	}

	/**
	 * Localiser le device
	 */
	private void localiserDevice() {
		locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);

		Location lastLocation = locationManager
				.getLastKnownLocation(LocationManager.GPS_PROVIDER);
		if (lastLocation != null) {
			updateLoc(lastLocation);
		} else {
			lastLocation = locationManager
					.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
			if (lastLocation != null) {
				updateLoc(lastLocation);
			} else {
				GeoPoint startPoint = new GeoPoint(48.13, -1.74098);
				myMapController.setCenter(startPoint);
			}
		}
	}

	// Implémentation de l'Action Bar

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.layout.action_bar_osm, menu);
		searchItem = menu.findItem(R.id.action_bar_osm_search);
		searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
		searchView.setInputType(InputType.TYPE_CLASS_TEXT
				| InputType.TYPE_TEXT_FLAG_CAP_WORDS);
		searchView.setQueryHint(getString(R.string.find_city));
		searchView.setOnQueryTextListener(queryTextListener);
		return super.onCreateOptionsMenu(menu);
	}

	/**
	 * Méthode qui se déclenchera au clic sur un item
	 */
	public boolean onOptionsItemSelected(MenuItem item) {
		// On regarde quel item a été cliqué grâce à son id et on déclenche une
		// action
		if (item.getItemId() == R.id.action_bar_osm_find) {
			localiserDevice();
			return true;
		} else if (item.getItemId() == R.id.action_bar_osm_cyclemap) {
			if (item.isChecked())
				item.setChecked(false);
			else
				item.setChecked(true);
			myOpenMapView.setTileSource(TileSourceFactory.CYCLEMAP);
			return true;
		} else if (item.getItemId() == R.id.action_bar_osm_mapnik) {
			if (item.isChecked())
				item.setChecked(false);
			else
				item.setChecked(true);
			myOpenMapView.setTileSource(TileSourceFactory.MAPNIK);
			return true;
		} else if (item.getItemId() == R.id.action_bar_osm_mapquestosm) {
			if (item.isChecked())
				item.setChecked(false);
			else
				item.setChecked(true);
			myOpenMapView.setTileSource(TileSourceFactory.MAPQUESTOSM);
			return true;
		} else if (item.getItemId() == R.id.action_bar_osm_public_transport) {
			if (item.isChecked())
				item.setChecked(false);
			else
				item.setChecked(true);
			myOpenMapView.setTileSource(TileSourceFactory.PUBLIC_TRANSPORT);
			return true;
		} else if (item.getItemId() == R.id.action_bar_osm_mapquestaerial) {
			if (item.isChecked())
				item.setChecked(false);
			else
				item.setChecked(true);
			myOpenMapView.setTileSource(TileSourceFactory.MAPQUESTAERIAL);
			return true;
		} else
			return false;
	}

	// Implémentation de la search View

	/**
	 * Argument permettant de personnaliser le listener de la searchView
	 */
	private final SearchView.OnQueryTextListener queryTextListener = new SearchView.OnQueryTextListener() {

		@Override
		public boolean onQueryTextSubmit(String query) {
			String city = searchView.getQuery() + "";
			findNewCity(new City(city));
			searchView.clearFocus();
			return false;
		}

		@Override
		public boolean onQueryTextChange(String arg0) {
			// TODO Auto-generated method stub
			return false;
		}
	};

	/**
	 * Prépare l'URL pour la connection en ligne
	 * 
	 * @param apid
	 * @param loc
	 * @param coordX
	 * @param coordY
	 * @return
	 */
	private String prepareURL(String apid, City loc, int coordX, int coordY) {
		String res = "http://api.openweathermap.org/data/2.5/weather";
		if (loc.hasVille()) {
			res += "?q=" + loc.getVille();
		} else {
			if (loc.hasLongLat()) {
				res += "?lon=" + loc.getLongitude() + "&lat="
						+ loc.getLatitude();
			}
		}
		res += "&units=metric";
		res += "&mode=json";
		res += "&APPID=" + apid;
		Log.v("AMS::Meteo", "URL de récupération des données météo : " + res);
		return res;
	}

	/**
	 * Recherche d'une nouvelle ville
	 * 
	 * @param loc
	 */
	private void findNewCity(City loc) {
		String cityURL = prepareURL(APIID, loc, 0, 0);
		new LayoutRefresher().execute(cityURL);
	}

	/**
	 * Récupère les coordonnées de la ville recherchée
	 * 
	 * @param urlString
	 * @param ctx
	 */
	private void locateNewCity(final String urlString, final Context ctx) {
		// Get all fields to be updated

		country = null;
		progressDialog.setTitle(getString(R.string.searching_city));
		progressDialog.setMessage(getString(R.string.move_to_city));
		progressDialog.setCanceledOnTouchOutside(false);
		progressDialog.show();

		Runnable code = new Runnable() {
			URL url = null;

			public void run() {
				try {
					// On récupère le JSON a partir de l'URL
					url = new URL(urlString);
					HttpURLConnection urlConnection;
					urlConnection = (HttpURLConnection) url.openConnection();
					BufferedInputStream in = new BufferedInputStream(
							urlConnection.getInputStream());
					String input = readStream(in);
					JSONObject json = new JSONObject(input);
					if (json.getInt("cod") == 404) {
						// La ville n'a pas été trouvée
						throw new CityNotFoundException(
								getString(R.string.CityNotFoundException_message));
					} else {
						Log.i(TAG, input);
						Log.i(TAG, json.toString());
						longitude = json.getJSONObject("coord")
								.getDouble("lon");
						latitude = json.getJSONObject("coord").getDouble("lat");
						country = json.getJSONObject("sys")
								.getString("country");
						runOnUiThread(new Runnable() {
							public void run() {
								moveToSearchedCity(latitude, longitude);
							}
						});
					}

				} catch (MalformedURLException e) {
					Log.e(TAG, "URL malformée");
					e.printStackTrace();
				} catch (IOException e) {
					Log.e(TAG, "Exception d'E/S");
					e.printStackTrace();
				} catch (JSONException e) {
					Log.e(TAG, "Exception JSON");
					e.printStackTrace();
				} catch (CityNotFoundException e) {
					runOnUiThread(new Runnable() {
						public void run() {
							String city = searchView.getQuery() + "";
							Toast.makeText(
									ctx,
									getString(
											R.string.CityNotFoundException_toast,
											city), Toast.LENGTH_LONG).show();
						}
					});
				}
				runOnUiThread(new Runnable() {
					public void run() {
						if (country != null) {
							String city = searchView.getQuery() + "";
							city += " (" + country + ")";
							searchView.setQuery(city, false);
						}
					}
				});
				progressDialog.dismiss();
			}
		};
		new Thread(code).start();
	}

	/**
	 * 
	 * @param cityURL
	 */
	private void downloadData(String cityURL) {
		// On récupère le JSON a partir de l'URL
		URL url;
		try {
			// On récupère le JSON a partir de l'URL
			url = new URL(cityURL);
			HttpURLConnection urlConnection;
			urlConnection = (HttpURLConnection) url.openConnection();
			BufferedInputStream in = new BufferedInputStream(
					urlConnection.getInputStream());
			String input = readStream(in);
			JSONObject json = new JSONObject(input);
			if (json.getInt("cod") == 404) {
				// La ville n'a pas été trouvée
				throw new CityNotFoundException(
						getString(R.string.CityNotFoundException_message));
			} else {
				Log.i(TAG, input);
				Log.i(TAG, json.toString());
				longitude = json.getJSONObject("coord").getDouble("lon");
				latitude = json.getJSONObject("coord").getDouble("lat");
				country = json.getJSONObject("sys").getString("country");
			}

		} catch (MalformedURLException e) {
			Log.e(TAG, "URL malformée");
			e.printStackTrace();
		} catch (IOException e) {
			Log.e(TAG, "Exception d'E/S");
			e.printStackTrace();
		} catch (JSONException e) {
			Log.e(TAG, "Exception JSON");
			e.printStackTrace();
		} catch (CityNotFoundException e) {
			runOnUiThread(new Runnable() {
				public void run() {
					String city = searchView.getQuery() + "";
					Toast.makeText(
							OSM.this,
							getString(R.string.CityNotFoundException_toast,
									city), Toast.LENGTH_LONG).show();
				}
			});
			e.printStackTrace();
		}
	}

	private class LayoutRefresher extends AsyncTask<String, Void, Void> {

		private ProgressDialog progressDialog;

		public LayoutRefresher() {
			this.progressDialog = new ProgressDialog(OSM.this);
			this.progressDialog.setTitle(getString(R.string.searching_city));
			this.progressDialog.setMessage(getString(R.string.move_to_city));
		}

		@Override
		protected void onPreExecute() {
			this.progressDialog.show();
			this.progressDialog.setCanceledOnTouchOutside(false);
		}

		@Override
		protected Void doInBackground(String... params) {
			downloadData(params[0]);
			return null;
		}

		@Override
		protected void onPostExecute(Void unused) {
			if (country != null) {
				String city = searchView.getQuery() + "";
				city += " (" + country + ")";
				searchView.setQuery(city, false);
			}
			moveToSearchedCity(latitude, longitude);
			if (this.progressDialog.isShowing()) {
				this.progressDialog.dismiss();
			}
		}
	}

	/**
	 * Lit un flux de données et retourne le string correspondant
	 * 
	 * @param inputStream
	 * @return
	 * @throws IOException
	 */
	private String readStream(InputStream inputStream) throws IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(
				inputStream));
		String ligne = null;
		String contenu = "";
		while ((ligne = reader.readLine()) != null) {
			contenu += ligne;
		}
		return contenu;
	}

	// Gestion de la map

	/**
	 * Positionne la carte à l'écran
	 * 
	 * @param loc
	 */
	private void updateLoc(Location loc) {
		GeoPoint locGeoPoint = new GeoPoint(loc.getLatitude(),
				loc.getLongitude());
		myMapController.setCenter(locGeoPoint);
		setOverlayLoc(loc);
	}

	/**
	 * Met en forme la carte avec l'icone
	 * 
	 * @param overlayloc
	 */
	private void setOverlayLoc(Location overlayloc) {
		GeoPoint overlocGeoPoint = new GeoPoint(overlayloc);
		// ---
		overlayItemArray.clear();
		OverlayItem newMyLocationItem = new OverlayItem("My Location",
				"My Location", overlocGeoPoint);
		overlayItemArray.add(newMyLocationItem);
		// ---
	}

	/**
	 * Méthode permettant l'animation d'une ville à une autre
	 * 
	 * @param lat
	 * @param lng
	 */
	private void moveToSearchedCity(double lat, double lng) {
		// ---Add a location marker---
		GeoPoint p = new GeoPoint(lat, lng);
		myMapController.animateTo(p);
		myMapController.setCenter(p);
		overlayItemArray = new ArrayList<OverlayItem>();

		// Put overlay icon a little way from map center
		overlayItemArray
				.add(new OverlayItem("Here u r", "SampleDescription", p));
	}

	/**
	 * Classe permettant de personnaliser la map
	 */
	public class MyItemizedIconOverlay extends ItemizedIconOverlay<OverlayItem> {

		public MyItemizedIconOverlay(
				List<OverlayItem> pList,
				org.osmdroid.views.overlay.ItemizedIconOverlay.OnItemGestureListener<OverlayItem> pOnItemGestureListener,
				ResourceProxy pResourceProxy) {
			super(pList, pOnItemGestureListener, pResourceProxy);
			// TODO Auto-generated constructor stub
		}

		@Override
		public void draw(Canvas canvas, MapView mapview, boolean arg2)
				throws IndexOutOfBoundsException {
			// TODO Auto-generated method stub
			super.draw(canvas, mapview, arg2);

			if (overlayItemArray != null && overlayItemArray.size() != 0) {

				GeoPoint in = overlayItemArray.get(0).getPoint();

				Point out = new Point();
				mapview.getProjection().toPixels(in, out);

				Bitmap bm = BitmapFactory.decodeResource(getResources(),
						R.drawable.ic_action_location_found);
				canvas.drawBitmap(bm, out.x - bm.getWidth() / 2, // shift the
																	// bitmap
																	// center
						out.y - bm.getHeight() / 2, // shift the bitmap center
						null);
			}
		}

		@Override
		public boolean onSingleTapUp(MotionEvent event, MapView mapView) {

			return true;
		}

		@Override
		public boolean onSingleTapConfirmed(MotionEvent event, MapView mapView) {
			return true;

		}
	}
}
